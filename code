<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <!-- パート1 -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>将棋ゲーム（チェスクロック付き）</title>
  <style>
    /* 全要素に box-sizing を適用 */
    * { 
      box-sizing: border-box; 
    }
    /* 基本スタイル */
    body {
      background: #FDF8F2;
      font-family: "Segoe UI", sans-serif;
      margin: 20px;
      padding: 20px;
      color: #333;
    }
    /* タイマー設定エリア */
    .timer-settings {
      margin-bottom: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
    }
    .timer-settings label {
      font-size: 14px;
    }
    
    /* 変則将棋モード設定エリア */
    .variant-settings {
      margin-bottom: 10px;
      padding: 10px;
      background: #EFEAE2;
      border: 1px solid #BFA37E;
      border-radius: 5px;
    }
    .variant-settings h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      text-align: center;
    }
    .variant-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }
    .variant-checkboxes label {
      font-size: 12px;
      white-space: nowrap;
    }
    .variant-checkboxes input[type="checkbox"] {
      margin-right: 5px;
    }
    .variant-detail {
      margin-top: 10px;
      padding: 5px;
      background: #FDF8F2;
      border-radius: 3px;
      font-size: 12px;
    }
    
    /* メインコンテナ：タイマーとゲームエリア */
    #main-container {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    /* タイマーコンテナ（全画面時は非表示） */
    #sente-timer-container,
    #gote-timer-container {
      width: 100px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    /* ゲームエリア（盤と持駒エリア） */
    #game-area {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    /* 盤エリア */
    #board-container {
      width: 450px;
      height: 450px;
      background: #FDF8F2;
      border: 1px solid #BFA37E;
      overflow: hidden;
      position: relative;
    }
    /* 盤テーブル：幅・高さを親に合わせ、９分割のセルサイズに */
    #board-container .board {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100%;
      height: 100%;
      transform: translate(-50%, -50%) rotate(90deg);
      transform-origin: center;
      border-collapse: collapse;
    }
    /* 各セルは親幅の1/9 */
    table.board td {
      width: calc(100% / 9);
      height: calc(100% / 9);
      border: 1px solid #DDD;
      background: #FDF8F2;
      text-align: center;
      vertical-align: middle;
      position: relative;
      overflow: hidden;
    }
    table.board td.selected { background-color: #E0F7FA; }
    table.board td.highlight { background-color: #BBDEFB; }
    table.board td.shadow-piece { background-color: #FFE0E0; }
    
    /* 配置フェーズ用のスタイル */
    #setup-complete-button {
      background-color: #4CAF50 !important;
      color: white !important;
      border: none !important;
      padding: 10px 20px !important;
      font-size: 18px !important;
      border-radius: 5px !important;
      cursor: pointer !important;
      margin: 0 5px !important;
    }
    
    #setup-complete-button:hover {
      background-color: #45a049 !important;
    }
    
    /* タイマー・時計ボックス */
    .clock {
      position: relative;
      font-size: 24px;
      font-weight: bold;
      padding: 5px 40px 5px 10px;
      background: #EFEAE2;
      border: 1px solid #BFA37E;
      border-radius: 5px;
      width: 100px;
      text-align: center;
    }
    #sente-clock { transform: rotate(90deg); }
    #gote-clock { transform: rotate(270deg); }
    #sente-clock .role-display,
    #gote-clock .role-display {
      position: absolute;
      right: -20px;
      top: 50%;
      transform: translateY(-50%) rotate(-90deg);
      font-size: 14px;
    }
    #gote-clock .role-display { transform: translateY(-50%) rotate(90deg); }
    /* 持駒エリア（駒台） */
    #sente-hand-container,
    #gote-hand-container {
      height: 450px;
      width: 100px;
      background: #EFEAE2;
      border: 1px solid #BFA37E;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 5px;
      position: relative;
    }
    
    /* 駒台内タイマー */
    .hand-timer {
      position: absolute;
      bottom: 5px;
      right: 5px;
      background: rgba(0, 0, 0, 0.3);
      color: white;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: bold;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      z-index: 10;
    }
    
    #sente-hand-container .hand-timer {
      transform: rotate(0deg);
      transform-origin: center;
    }
    
    #gote-hand-container .hand-timer {
      transform: rotate(180deg);
      transform-origin: center;
    }
    /* 盤上の駒デザイン – 共通（セルの80%） */
    .piece, .hand-piece {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 80%;
      height: 80%;
      font-size: 1em;
      font-weight: bold;
      color: #5A3B1C;
      background: linear-gradient(135deg, #FDF0D5, #E8C699);
      border: 2px solid #7B5E3A;
      clip-path: polygon(50% 0%, 100% 25%, 92% 100%, 8% 100%, 0% 25%);
      user-select: none;
      cursor: pointer;
    }
    /* 盤上の駒の場合 */
    #board-container .piece { 
      transform: rotate(0deg); 
    }
    #board-container .piece.gote { 
      transform: rotate(180deg); 
    }
    /* 持駒は回転させるが、サイズは JS で動的に調整するため固定指定はせず */
    .hand-piece { 
      transform: rotate(90deg);
    }
    #gote-hand-container .hand-piece { 
      transform: rotate(270deg); 
    }
    /* 持ち駒が選択されたときのハイライト */
    .hand-piece.selected {
      background-color: #E0F7FA;
      border-color: #00796B;
      color: #00796B;
    }
    /* メッセージ表示 */
    #message {
      text-align: center;
      font-weight: bold;
      margin-bottom: 10px;
    }
    /* リセット・先後入れ替え・全画面モードボタン */
    .reset-container {
      margin-top: 10px;
      text-align: center;
    }
    .reset-container button {
      font-size: 16px;
      padding: 5px 15px;
      margin: 0 5px;
    }
    
    /* --- 全画面モード用のスタイル --- */
    :fullscreen body,
    :-webkit-full-screen body,
    :-moz-full-screen body,
    :-msfullscreen body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    :fullscreen #sente-timer-container,
    :-webkit-full-screen #sente-timer-container,
    :-moz-full-screen #sente-timer-container,
    :-msfullscreen #sente-timer-container,
    :fullscreen #gote-timer-container,
    :-webkit-full-screen #gote-timer-container,
    :-moz-full-screen #gote-timer-container,
    :-msfullscreen #gote-timer-container {
      display: none;
    }
    :fullscreen #game-area,
    :-webkit-full-screen #game-area,
    :-moz-full-screen #game-area,
    :-msfullscreen #game-area {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      gap: 0;
      display: flex;
      flex-direction: row;
    }
    
    /* 持ち駒サイズ更新は JS に任せるため、ここではダミー関数 */
  </style>
</head>
<body>
  <!-- タイマー設定 -->
  <div class="timer-settings">
    <span>初期時間:</span>
    <input id="initial-time" type="number" value="10" min="1"> 分
    <span>タイマーモード:</span>
    <label><input type="radio" name="timer-mode" value="instant" checked> 切れ負け</label>
    <label><input type="radio" name="timer-mode" value="delay"> 切れたら10秒</label>
    <label><input type="radio" name="timer-mode" value="permove"> 1手10秒</label>
    <label><input type="radio" name="timer-mode" value="none"> 時間制限なし</label>
  </div>

  <!-- 変則将棋モード設定 -->
  <div class="variant-settings">
    <h3>変則将棋モード</h3>
    <div class="variant-checkboxes">
      <label><input type="checkbox" id="shadow-shogi"> 影武者将棋</label>
      <label><input type="checkbox" id="hidden-shogi"> かくし将棋</label>
      <label><input type="checkbox" id="double-move"> 2手指し将棋</label>
      <label><input type="checkbox" id="reflection-angle"> 反射角</label>
      <label><input type="checkbox" id="double-pawn"> 2歩あり将棋</label>
      <label><input type="checkbox" id="capital-return"> 資本還元将棋</label>
      <label><input type="checkbox" id="check-shogi"> 王手将棋</label>
    </div>
    <div class="variant-detail">
      <div id="capital-return-setting" style="display: none;">
        資本還元将棋の持ち駒上限: <input type="number" id="capital-limit" value="4" min="1" max="10"> 枚
      </div>
    </div>
  </div>
  
  <!-- メインコンテナ -->
  <div id="main-container">
    <!-- タイマー（通常表示、全画面時は非表示） -->
    <div id="sente-timer-container">
      <div id="sente-clock" class="clock">
        <div class="clock-content">
          <span class="time-display">10:00</span>
          <span class="role-display" data-original="先手">先手</span>
        </div>
      </div>
    </div>
    
    <!-- ゲームエリア：盤と持駒エリア -->
    <div id="game-area">
      <div id="sente-hand-container">
        <div class="hand-area" id="sente-hand-area"></div>
        <div class="hand-timer" id="sente-hand-timer">10:00</div>
      </div>
      <div id="board-container">
        <table class="board">
          <tbody id="board-body"></tbody>
        </table>
      </div>
      <div id="gote-hand-container">
        <div class="hand-area" id="gote-hand-area"></div>
        <div class="hand-timer" id="gote-hand-timer">10:00</div>
      </div>
    </div>
    
    <div id="gote-timer-container">
      <div id="gote-clock" class="clock">
        <div class="clock-content">
          <span class="time-display">10:00</span>
          <span class="role-display" data-original="後手">後手</span>
        </div>
      </div>
    </div>
  </div>
  
  <!-- パート2 -->
  <div id="message"></div>

  <!-- リセット・先後入れ替え・全画面モードボタン -->
  <div class="reset-container">
    <button id="reset-button">リセット</button>
    <button id="swap-button">先後を入れ替える</button>
    <button id="fullscreen-button">全画面モード</button>
    <button id="undo-button">待った</button>
    <button id="replay-button">棋譜再生</button>
  </div>

  <!-- タイマー関連スクリプト -->
  <script>
    let timerInterval = null;
    let senteTime = 600;
    let goteTime = 600;
    let timerMode = "instant"; // "instant" または "delay"
    const delayTime = 10;
    let activeTimerPlayer = null;
    let delayActivatedSente = false;
    let delayActivatedGote = false;
    let swapped = false;

    function formatTime(seconds) {
      const m = Math.floor(Math.abs(seconds) / 60);
      const s = Math.abs(seconds) % 60;
      const sign = seconds < 0 ? "-" : "";
      return sign + ("0" + m).slice(-2) + ":" + ("0" + s).slice(-2);
    }

    function updateClockDisplay() {
      document.querySelector("#sente-clock .time-display").textContent = formatTime(senteTime);
      document.querySelector("#gote-clock .time-display").textContent = formatTime(goteTime);
      
      // 駒台のタイマーも更新
      document.getElementById("sente-hand-timer").textContent = formatTime(senteTime);
      document.getElementById("gote-hand-timer").textContent = formatTime(goteTime);
    }

    function getRoleName(player) {
      return swapped
        ? (player === "sente" ? "後手" : "先手")
        : (player === "sente" ? "先手" : "後手");
    }

    function initializeTimer() {
      const initialTime = parseInt(document.getElementById("initial-time").value);
      senteTime = initialTime * 60;
      goteTime = initialTime * 60;
      delayActivatedSente = false;
      delayActivatedGote = false;
      const radios = document.getElementsByName("timer-mode");
      for (const radio of radios) {
        if (radio.checked) { timerMode = radio.value; }
      }
      updateClockDisplay();
      
      // 駒台タイマーのサイズも初期化
      updateHandTimersSize(450);
    }

    function startTimerForPlayer(player) {
      activeTimerPlayer = player;
      if (timerInterval) clearInterval(timerInterval);
      if (timerMode === "none") {
        // 時間制限なし
        return;
      }
      timerInterval = setInterval(() => {
        if (timerMode === "permove") {
          // 1手10秒モード
          if (player === "sente") {
            senteTime = 10;
          } else {
            goteTime = 10;
          }
          updateClockDisplay();
          clearInterval(timerInterval);
          let permoveTimer = 10;
          timerInterval = setInterval(() => {
            if (player === "sente") {
              senteTime--;
              permoveTimer--;
              if (senteTime <= 0) {
                clearInterval(timerInterval);
                alert(`${getRoleName("sente")}の1手10秒超過です！${getRoleName("gote")}の勝ちです。`);
              }
            } else {
              goteTime--;
              permoveTimer--;
              if (goteTime <= 0) {
                clearInterval(timerInterval);
                alert(`${getRoleName("gote")}の1手10秒超過です！${getRoleName("sente")}の勝ちです。`);
              }
            }
            updateClockDisplay();
          }, 1000);
          return;
        }
        if (player === "sente") {
          if (timerMode === "instant") {
            senteTime--;
            if (senteTime <= 0) {
              clearInterval(timerInterval);
              alert(`${getRoleName("sente")}の時間切れです！${getRoleName("gote")}の勝ちです。`);
            }
          } else if (timerMode === "delay") {
            if (!delayActivatedSente) {
              if (senteTime > 0) {
                senteTime--;
                if (senteTime === 0) {
                  senteTime = delayTime;
                  delayActivatedSente = true;
                }
              }
            } else {
              senteTime--;
              if (senteTime <= 0) {
                clearInterval(timerInterval);
                alert(`${getRoleName("sente")}の10秒以内の指し手がありません。${getRoleName("gote")}の勝ちです。`);
              }
            }
          }
        } else {
          if (timerMode === "instant") {
            goteTime--;
            if (goteTime <= 0) {
              clearInterval(timerInterval);
              alert(`${getRoleName("gote")}の時間切れです！${getRoleName("sente")}の勝ちです。`);
            }
          } else if (timerMode === "delay") {
            if (!delayActivatedGote) {
              if (goteTime > 0) {
                goteTime--;
                if (goteTime === 0) {
                  goteTime = delayTime;
                  delayActivatedGote = true;
                }
              }
            } else {
              goteTime--;
              if (goteTime <= 0) {
                clearInterval(timerInterval);
                alert(`${getRoleName("gote")}の10秒以内の指し手がありません。${getRoleName("sente")}の勝ちです。`);
              }
            }
          }
        }
        updateClockDisplay();
      }, 1000);
    }

    function pauseTimer() {
      if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
    }

    function switchClock() {
      pauseTimer();
      if (activeTimerPlayer === "sente") { startTimerForPlayer("gote"); }
      else { startTimerForPlayer("sente"); }
    }

    function switchTurn() {
      if (timerMode === "delay") {
        if (gameState.activePlayer === "sente" && delayActivatedSente) { senteTime = delayTime; }
        else if (gameState.activePlayer === "gote" && delayActivatedGote) { goteTime = delayTime; }
      }
      
      // 2手指し将棋の場合
      if (gameState.variants.doubleMove && gameState.moveCountInTurn === 0) {
        gameState.moveCountInTurn = 1;
        updateMessage();
        updateUndoButtonState();
        return; // ターン変更なし
      }
      
      gameState.activePlayer = (gameState.activePlayer === "sente") ? "gote" : "sente";
      gameState.moveCountInTurn = 0;
      updateMessage();
      updateUndoButtonState();
      switchClock();
    }

    function updateMessage() {
      let message;
      if (gameState.replayMode) {
        message = "棋譜再生モード";
      } else if (gameState.setupPhase) {
        const player = getRoleName(gameState.setupPhase);
        const area = gameState.setupPhase === "sente" ? "6,7,8段目" : "1,2,3段目";
        message = `かくし将棋: ${player}の配置フェーズ - 駒台の駒を選択して${area}に配置してください（配置済みの駒をクリックすると駒台に戻せます）`;
      } else if (gameState.shadowSelectionPhase) {
        const player = getRoleName(gameState.shadowSelectionPhase);
        message = `影武者将棋: ${player}の影武者駒選択フェーズ - 自分の駒をクリックして影武者駒を選択してください（王も可）`;
      } else {
        const currentPlayer = getRoleName(gameState.activePlayer);
        message = `${currentPlayer}の番`;
        if (gameState.variants.doubleMove && gameState.moveCountInTurn === 0) {
          message += " (1手目)";
        } else if (gameState.variants.doubleMove && gameState.moveCountInTurn === 1) {
          message += " (2手目)";
        }
        
        // 待った使用状況を表示
        const undoStatus = [];
        if (gameState.undoUsed.sente) undoStatus.push(`${getRoleName("sente")}：使用済み`);
        if (gameState.undoUsed.gote) undoStatus.push(`${getRoleName("gote")}：使用済み`);
        if (undoStatus.length > 0) {
          message += ` (待った: ${undoStatus.join(", ")})`;
        }
      }
      document.getElementById("message").textContent = message;
    }
    // パート3
  </script>

<script>
  let gameState;
  let legalMoves = new Set();

  function cellId(r, c) { return r + "-" + c; }

  function cloneGameState(state) { return JSON.parse(JSON.stringify(state)); }

  // --- 棋譜再生機能を1から再設計 ---
  function saveGameState() {
    if (gameState.replayMode) return;
    // 盤面・持ち駒・手番などをディープコピー
    const snapshot = {
      board: JSON.parse(JSON.stringify(gameState.board)),
      senteHand: JSON.parse(JSON.stringify(gameState.senteHand)),
      goteHand: JSON.parse(JSON.stringify(gameState.goteHand)),
      activePlayer: gameState.activePlayer,
      moveCount: gameState.moveCount,
      moveCountInTurn: gameState.moveCountInTurn,
      shadowPieces: JSON.parse(JSON.stringify(gameState.shadowPieces)),
      pieceIdCounter: gameState.pieceIdCounter,
      swapped: swapped
    };
    gameState.gameHistory.push(snapshot);
  }

  function canUndo() {
    if (gameState.replayMode) return false;
    if (gameState.setupPhase || gameState.shadowSelectionPhase) return false;
    if (gameState.undoUsed[gameState.activePlayer]) return false;
    
    // 2手指し将棋の場合の特別処理
    if (gameState.variants.doubleMove) {
      if (gameState.moveCountInTurn === 0) {
        // ターンの最初の場合：4手必要
        return gameState.gameHistory.length >= 4;
      } else {
        // ターンの2手目の場合：3手必要
        return gameState.gameHistory.length >= 3;
      }
    } else {
      // 通常将棋の場合：2手必要
      return gameState.gameHistory.length >= 2;
    }
  }

  function performUndo() {
    if (!canUndo()) {
      alert("待ったできません。");
      return;
    }
    
    if (gameState.undoUsed[gameState.activePlayer]) {
      alert("このプレイヤーは既に待ったを使用済みです。");
      return;
    }
    
    // 待ったを使用したプレイヤーを記録
    const undoPlayer = gameState.activePlayer;
    
    // 2手指し将棋の場合の特別処理
    if (gameState.variants.doubleMove) {
      let movesToUndo;
      
      if (gameState.moveCountInTurn === 0) {
        // ターンの最初の場合：相手の2手と自分の前の2手を戻す（計4手）
        movesToUndo = 4;
      } else {
        // ターンの2手目の場合：自分の1手目と相手の前の2手を戻す（計3手）
        movesToUndo = 3;
      }
      
      // 指定した手数分巻き戻す
      for (let i = 0; i < movesToUndo && gameState.gameHistory.length > 0; i++) {
        gameState.gameHistory.pop();
      }
    } else {
      // 通常将棋の場合：2手分巻き戻す
      gameState.gameHistory.pop(); // 現在の状態を削除
      if (gameState.gameHistory.length > 0) {
        gameState.gameHistory.pop(); // 相手の前の手も削除
      }
    }
    
    if (gameState.gameHistory.length > 0) {
      const previousState = gameState.gameHistory[gameState.gameHistory.length - 1];
      restoreGameState(previousState);
      // 待ったを使用したプレイヤーのフラグを設定
      gameState.undoUsed[undoPlayer] = true;
      // 待ったを使用したプレイヤーが再びターンを持つ
      gameState.activePlayer = undoPlayer;
    } else {
      // 初期状態に戻す
      initGame();
      gameState.undoUsed[undoPlayer] = true;
      gameState.activePlayer = undoPlayer;
      return;
    }
    
    renderBoard();
    updateMessage();
    updateUndoButtonState();
    
    // タイマーを現在のプレイヤーに合わせる
    if (timerInterval) {
      pauseTimer();
      startTimerForPlayer(gameState.activePlayer);
    }
  }

  function restoreGameState(stateStr) {
    const snapshot = stateStr;
    gameState.board = JSON.parse(JSON.stringify(snapshot.board));
    gameState.senteHand = JSON.parse(JSON.stringify(snapshot.senteHand));
    gameState.goteHand = JSON.parse(JSON.stringify(snapshot.goteHand));
    gameState.activePlayer = snapshot.activePlayer;
    gameState.moveCount = snapshot.moveCount;
    gameState.moveCountInTurn = snapshot.moveCountInTurn;
    gameState.shadowPieces = JSON.parse(JSON.stringify(snapshot.shadowPieces));
    gameState.pieceIdCounter = snapshot.pieceIdCounter;
    swapped = snapshot.swapped;
    gameState.selected = null;
    updateMessage();
    updateRoleDisplays();
  }

  function enterReplayMode() {
    if (gameState.gameHistory.length === 0) {
      alert("棋譜がありません。");
      return;
    }
    saveGameState(); // 最新局面も保存
    if (confirm("棋譜再生モードに移行しますか？")) {
      gameState.replayMode = true;
      gameState.replayPosition = 0;
      pauseTimer();
      showReplayControls();
      restoreGameState(gameState.gameHistory[gameState.replayPosition]);
      renderBoard();
      updateMessage();
    }
  }

  function exitReplayMode() {
    // 棋譜再生終了時は最新の盤面に戻す
    if (gameState.gameHistory.length > 0) {
      restoreGameState(gameState.gameHistory[gameState.gameHistory.length - 1]);
    }
    gameState.replayMode = false;
    gameState.replayPosition = -1;
    hideReplayControls();
    renderBoard();
    updateMessage();
    if (gameState.gameHistory.length > 0) {
      startTimerForPlayer(gameState.activePlayer);
    }
  }

  function replayPrevious() {
    if (gameState.replayPosition > 0) {
      gameState.replayPosition--;
      restoreGameState(gameState.gameHistory[gameState.replayPosition]);
      renderBoard();
      updateMessage();
    }
  }

  function replayNext() {
    if (gameState.replayPosition < gameState.gameHistory.length - 1) {
      gameState.replayPosition++;
      restoreGameState(gameState.gameHistory[gameState.replayPosition]);
      renderBoard();
      updateMessage();
    }
  }

  function replayFirst() {
    if (gameState.gameHistory.length > 0) {
      gameState.replayPosition = 0;
      restoreGameState(gameState.gameHistory[0]);
      renderBoard();
      updateMessage();
    }
  }

  function replayLast() {
    if (gameState.gameHistory.length > 0) {
      gameState.replayPosition = gameState.gameHistory.length - 1;
      restoreGameState(gameState.gameHistory[gameState.replayPosition]);
      renderBoard();
      updateMessage();
    }
  }

  function showReplayControls() {
    // 棋譜再生コントロールを表示
    const replayControls = document.createElement("div");
    replayControls.id = "replay-controls";
    replayControls.style.textAlign = "center";
    replayControls.style.margin = "10px";
    replayControls.style.padding = "10px";
    replayControls.style.backgroundColor = "#f0f0f0";
    replayControls.style.borderRadius = "5px";
    
    let moveNum = (gameState.replayPosition >= 0) ? gameState.replayPosition + 1 : 0;
    const controlsHTML = `
      <div style="margin-bottom: 10px;">
        <strong>棋譜再生モード</strong> 
        <span style="margin-left: 20px;">手数: ${moveNum}/${gameState.gameHistory.length}</span>
      </div>
      <div>
        <button onclick="replayFirst()" style="margin: 2px; padding: 5px 10px;"><<</button>
        <button onclick="replayPrevious()" style="margin: 2px; padding: 5px 10px;"><</button>
        <button onclick="replayNext()" style="margin: 2px; padding: 5px 10px;">></button>
        <button onclick="replayLast()" style="margin: 2px; padding: 5px 10px;">>></button>
        <button onclick="exitReplayMode()" style="margin: 2px 2px 2px 20px; padding: 5px 10px; background-color: #ff4444; color: white;">棋譜再生終了</button>
      </div>
    `;
    // コントロールを再描画するたびに手数表示を更新
    const old = document.getElementById("replay-controls");
    if (old) old.remove();
    
    replayControls.innerHTML = controlsHTML;
    
    const resetContainer = document.querySelector('.reset-container');
    resetContainer.appendChild(replayControls);
  }

  function hideReplayControls() {
    const replayControls = document.getElementById("replay-controls");
    if (replayControls) {
      replayControls.remove();
    }
  }

  function updateUndoButtonState() {
    const undoButton = document.getElementById("undo-button");
    if (undoButton) {
      if (canUndo()) {
        undoButton.disabled = false;
        undoButton.style.backgroundColor = "#4CAF50";
        undoButton.style.color = "white";
      } else {
        undoButton.disabled = true;
        undoButton.style.backgroundColor = "#ccc";
        undoButton.style.color = "#666";
      }
    }
  }

  // グローバル関数として公開
  window.replayFirst = replayFirst;
  window.replayPrevious = replayPrevious;
  window.replayNext = replayNext;
  window.replayLast = replayLast;
  window.exitReplayMode = exitReplayMode;

  function getLegalMovesInState(state, piece, r, c) {
    let moves = [];
    const owner = piece.owner;
    const forward = (owner === "sente") ? -1 : 1;
    if (piece.promoted && (piece.type === "pawn" || piece.type === "lance" ||
         piece.type === "knight" || piece.type === "silver")) {
      moves = moves.concat(getGoldMoves(state, owner, r, c));
    } else {
      switch (piece.type) {
        case "pawn": {
          const nr = r + forward;
          if (inBounds(nr, c) && (!state.board[nr][c] || state.board[nr][c].owner !== owner))
            moves.push({ r: nr, c: c });
          break;
        }
        case "lance":
          moves = moves.concat(getSlidingMoves(state, r, c, [[forward, 0]]));
          break;
        case "knight": {
          const offsets = (owner === "sente") ? [[-2,-1],[-2,1]] : [[2,-1],[2,1]];
          offsets.forEach(off => {
            const nr = r + off[0], nc = c + off[1];
            if (inBounds(nr, nc) && (!state.board[nr][nc] || state.board[nr][nc].owner !== owner))
              moves.push({ r: nr, c: nc });
          });
          break;
        }
        case "silver": {
          const offsets = (owner === "sente")
            ? [[-1,-1],[-1,0],[-1,1],[1,-1],[1,1]]
            : [[1,-1],[1,0],[1,1],[-1,-1],[-1,1]];
          offsets.forEach(off => {
            const nr = r + off[0], nc = c + off[1];
            if (inBounds(nr, nc) && (!state.board[nr][nc] || state.board[nr][nc].owner !== owner))
              moves.push({ r: nr, c: nc });
          });
          break;
        }
        case "gold":
          moves = moves.concat(getGoldMoves(state, owner, r, c));
          break;
        case "king": {
          const offsets = [
            [-1,-1],[-1,0],[-1,1],
            [0,-1],        [0,1],
            [1,-1],[1,0],[1,1]
          ];
          offsets.forEach(off => {
            const nr = r + off[0], nc = c + off[1];
            if (inBounds(nr, nc) && (!state.board[nr][nc] || state.board[nr][nc].owner !== owner))
              moves.push({ r: nr, c: nc });
          });
          break;
        }
        case "rook":
          moves = moves.concat(getSlidingMoves(state, r, c, [[-1,0],[1,0],[0,-1],[0,1]]));
          break;
        case "bishop":
          moves = moves.concat(getBishopMoves(state, r, c, owner));
          break;
        case "rook_promoted":
          moves = moves.concat(getSlidingMoves(state, r, c, [[-1,0],[1,0],[0,-1],[0,1]]));
          [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(off => {
            const nr = r + off[0], nc = c + off[1];
            if (inBounds(nr, nc) && (!state.board[nr][nc] || state.board[nr][nc].owner !== owner))
              moves.push({ r: nr, c: nc });
          });
          break;
        case "bishop_promoted":
          moves = moves.concat(getBishopMoves(state, r, c, owner));
          [[-1,0],[1,0],[0,-1],[0,1]].forEach(off => {
            const nr = r + off[0], nc = c + off[1];
            if (inBounds(nr, nc) && (!state.board[nr][nc] || state.board[nr][nc].owner !== owner))
              moves.push({ r: nr, c: nc });
          });
          break;
      }
    }
    return moves;
  }

  // 角行の移動（反射角対応）
  function getBishopMoves(state, r, c, owner) {
    const directions = [[-1,-1],[-1,1],[1,-1],[1,1]];
    let moves = [];
    
    if (state.variants.reflectionAngle) {
      // 反射角が有効な場合は反射移動のみ
      directions.forEach(dir => {
        let currentR = r;
        let currentC = c;
        let currentDir = [...dir];
        
        // 最大2回の反射まで許可
        for (let reflections = 0; reflections <= 2; reflections++) {
          let nr = currentR + currentDir[0];
          let nc = currentC + currentDir[1];
          let lastValidR = currentR;
          let lastValidC = currentC;
          
          // 現在の方向に移動
          while (inBounds(nr, nc)) {
            if (state.board[nr][nc]) {
              if (state.board[nr][nc].owner !== owner) {
                moves.push({ r: nr, c: nc });
              }
              break;
            } else {
              moves.push({ r: nr, c: nc });
              lastValidR = nr;
              lastValidC = nc;
            }
            nr += currentDir[0];
            nc += currentDir[1];
          }
          
          // 盤の端に到達した場合、反射を試みる
          if (!inBounds(nr, nc)) {
            let newDir = [...currentDir];
            let reflectionOccurred = false;
            
            // 反射方向を計算
            if (nr < 0 || nr >= 9) {
              newDir[0] = -newDir[0];
              reflectionOccurred = true;
            }
            if (nc < 0 || nc >= 9) {
              newDir[1] = -newDir[1];
              reflectionOccurred = true;
            }
            
            if (reflectionOccurred) {
              // 反射点は最後の有効な位置
              currentR = lastValidR;
              currentC = lastValidC;
              currentDir = newDir;
            } else {
              break; // 反射できない場合は終了
            }
          } else {
            break; // 駒に当たって停止した場合は終了
          }
        }
      });
    } else {
      // 通常の角行移動
      moves = moves.concat(getSlidingMoves(state, r, c, directions));
    }
    
    return moves;
  }

  function getLegalMoves(piece, r, c) {
    let moves = [];
    const owner = piece.owner;
    const forward = (owner === "sente") ? -1 : 1;
    if (piece.promoted && (piece.type === "pawn" || piece.type === "lance" ||
         piece.type === "knight" || piece.type === "silver")) {
      moves = moves.concat(getGoldMoves(gameState, owner, r, c));
    } else {
      switch (piece.type) {
        case "pawn": {
          const nr = r + forward;
          if (inBounds(nr, c) && (!gameState.board[nr][c] || gameState.board[nr][c].owner !== owner))
            moves.push({ r: nr, c: c });
          break;
        }
        case "lance":
          moves = moves.concat(getSlidingMoves(gameState, r, c, [[forward, 0]]));
          break;
        case "knight": {
          const offsets = (owner === "sente") ? [[-2,-1],[-2,1]] : [[2,-1],[2,1]];
          offsets.forEach(off => {
            const nr = r + off[0], nc = c + off[1];
            if (inBounds(nr, nc) && (!gameState.board[nr][nc] || gameState.board[nr][nc].owner !== owner))
              moves.push({ r: nr, c: nc });
          });
          break;
        }
        case "silver": {
          const offsets = (owner === "sente")
            ? [[-1,-1],[-1,0],[-1,1],[1,-1],[1,1]]
            : [[1,-1],[1,0],[1,1],[-1,-1],[-1,1]];
          offsets.forEach(off => {
            const nr = r + off[0], nc = c + off[1];
            if (inBounds(nr, nc) && (!gameState.board[nr][nc] || gameState.board[nr][nc].owner !== owner))
              moves.push({ r: nr, c: nc });
          });
          break;
        }
        case "gold":
          moves = moves.concat(getGoldMoves(gameState, owner, r, c));
          break;
        case "king": {
          const offsets = [
            [-1,-1],[-1,0],[-1,1],
            [0,-1],        [0,1],
            [1,-1],[1,0],[1,1]
          ];
          offsets.forEach(off => {
            const nr = r + off[0], nc = c + off[1];
            if (inBounds(nr, nc) && (!gameState.board[nr][nc] || gameState.board[nr][nc].owner !== owner))
              moves.push({ r: nr, c: nc });
          });
          break;
        }
        case "rook":
          moves = moves.concat(getSlidingMoves(gameState, r, c, [[-1,0],[1,0],[0,-1],[0,1]]));
          break;
        case "bishop":
          moves = moves.concat(getBishopMoves(gameState, r, c, owner));
          break;
        case "rook_promoted":
          moves = moves.concat(getSlidingMoves(gameState, r, c, [[-1,0],[1,0],[0,-1],[0,1]]));
          [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(off => {
            const nr = r + off[0], nc = c + off[1];
            if (inBounds(nr, nc) && (!gameState.board[nr][nc] || gameState.board[nr][nc].owner !== owner))
              moves.push({ r: nr, c: nc });
          });
          break;
        case "bishop_promoted":
          moves = moves.concat(getBishopMoves(gameState, r, c, owner));
          [[-1,0],[1,0],[0,-1],[0,1]].forEach(off => {
            const nr = r + off[0], nc = c + off[1];
            if (inBounds(nr, nc) && (!gameState.board[nr][nc] || gameState.board[nr][nc].owner !== owner))
              moves.push({ r: nr, c: nc });
          });
          break;
      }
    }
    
    // 影武者将棋の場合、自分の玉に王手をかけられる手でもOK
    if (gameState.variants.shadowShogi) {
      return moves;
    }
    
    return moves.filter(move => isMoveSafe(piece, r, c, move.r, move.c));
  }

  function isMoveSafe(piece, fromRow, fromCol, toRow, toCol) {
    const clone = cloneGameState(gameState);
    clone.board[toRow][toCol] = clone.board[fromRow][fromCol];
    clone.board[fromRow][fromCol] = null;
    
    // 影武者将棋の場合、玉の安全性チェックをスキップ
    if (gameState.variants.shadowShogi) {
      return true;
    }
    
    return !isKingInCheckInState(clone, piece.owner);
  }

  function inBounds(r, c) { return r >= 0 && r < 9 && c >= 0 && c < 9; }

  function getGoldMoves(state, owner, r, c) {
    let moves = [];
    const offsets = (owner === "sente")
      ? [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,0]]
      : [[1,-1],[1,0],[1,1],[0,-1],[0,1],[-1,0]];
    offsets.forEach(off => {
      const nr = r + off[0], nc = c + off[1];
      if (inBounds(nr, nc) && (!state.board[nr][nc] || state.board[nr][nc].owner !== owner))
        moves.push({ r: nr, c: nc });
    });
    return moves;
  }

  function getSlidingMoves(state, r, c, directions) {
    let moves = [];
    const owner = state.board[r][c].owner;
    directions.forEach(dir => {
      let nr = r + dir[0], nc = c + dir[1];
      while (inBounds(nr, nc)) {
        if (state.board[nr][nc]) {
          if (state.board[nr][nc].owner !== owner)
            moves.push({ r: nr, c: nc });
          break;
        } else {
          moves.push({ r: nr, c: nc });
        }
        nr += dir[0];
        nc += dir[1];
      }
    });
    return moves;
  }

  function getPieceSymbol(piece) {
    if (piece.type === "pawn") { return piece.promoted ? "と" : "歩"; }
    if (piece.promoted) {
      if (piece.type === "silver") return "全";
      if (piece.type === "knight") return "圭";
      if (piece.type === "lance") return "杏";
    }
    const symbols = {
      pawn: "歩",
      lance: "香",
      knight: "桂",
      silver: "銀",
      gold: "金",
      king: "玉",
      bishop: "角",
      rook: "飛",
      rook_promoted: "龍",
      bishop_promoted: "馬"
    };
    return symbols[piece.type] || piece.type;
  }

  function dropPiece(selected, r, c) {
    let piece;
    if (selected.owner === "sente") { 
      piece = gameState.senteHand.splice(selected.index, 1)[0]; 
    } else { 
      piece = gameState.goteHand.splice(selected.index, 1)[0]; 
    }
    gameState.board[r][c] = piece;
  }

  function isDropSafe(piece, dropRow, dropCol) {
    const clone = cloneGameState(gameState);
    clone.board[dropRow][dropCol] = piece;
    
    // 影武者将棋の場合、玉の安全性チェックをスキップ
    if (gameState.variants.shadowShogi) {
      return true;
    }
    
    return !isKingInCheckInState(clone, piece.owner);
  }

  function isLegalDrop(piece, r, c) {
    if (gameState.board[r][c] !== null) return false;
    
    // 2歩あり将棋でない場合、2歩をチェック
    if (piece.type === "pawn" && !gameState.variants.doublePawn) {
      for (let row = 0; row < 9; row++) {
        const p = gameState.board[row][c];
        if (p && p.owner === piece.owner && p.type === "pawn" && !p.promoted) {
          alert("二歩です。");
          return false;
        }
      }
    }
    
    if (piece.type === "pawn") {
      if (piece.owner === "sente" && r === 0) { alert("そこには打てません。"); return false; }
      if (piece.owner === "gote" && r === 8) { alert("そこには打てません。"); return false; }
    }
    
    if (!isDropSafe(piece, r, c)) { alert("ドロップ後に自玉が危険です。"); return false; }
    return true;
  }

  async function movePiece(fromRow, fromCol, toRow, toCol) {
    const piece = gameState.board[fromRow][fromCol];
    const target = gameState.board[toRow][toCol];
    
    // 王手将棋の場合、王手をかけたかチェック
    if (gameState.variants.checkShogi) {
      const clone = cloneGameState(gameState);
      clone.board[toRow][toCol] = clone.board[fromRow][fromCol];
      clone.board[fromRow][fromCol] = null;
      const opponent = (piece.owner === "sente") ? "gote" : "sente";
      // 影武者将棋も有効な場合は影武者駒のみ判定
      if (gameState.variants.shadowShogi) {
        const shadowPiece = findShadowPiece(clone, opponent);
        if (shadowPiece && isShadowPieceInCheck(clone, shadowPiece, piece.owner)) {
          alert(`${getRoleName(piece.owner)}の勝ちです！影武者駒に王手をかけました。`);
          return;
        }
        // 影武者将棋が有効な場合は通常の王手判定はスキップ
      } else {
        // 通常の王手チェック
        if (isKingInCheckInState(clone, opponent)) {
          alert(`${getRoleName(piece.owner)}の勝ちです！王手をかけました。`);
          return;
        }
      }
    }
    
    if (target) { 
      // 影武者将棋で影武者駒を取った場合
      if (gameState.variants.shadowShogi && isTargetShadowPiece(target)) {
        alert(`${getRoleName(piece.owner)}の勝ちです！影武者駒を取りました。`);
        return;
      }
      capturePiece(target); 
    }
    
    // 駒の移動を行う前に現在の状態を保存（棋譜再生時は保存しない）
    saveGameState();

    gameState.board[toRow][toCol] = piece;
    gameState.board[fromRow][fromCol] = null;

    // 資本還元将棋の手駒上限チェック
    if (gameState.variants.capitalReturn) {
      const handCount = gameState.activePlayer === "sente" ? 
        gameState.senteHand.length : gameState.goteHand.length;
      const limit = parseInt(document.getElementById("capital-limit").value);
      if (handCount > limit) {
        alert(`${getRoleName(gameState.activePlayer)}の負けです！持ち駒が${limit}枚を超えました。`);
        return;
      }
    }

    const promotionZone = (piece.owner === "sente") ? [0, 1, 2] : [6, 7, 8];
    if (!piece.promoted && isPromotable(piece.type)) {
      if (promotionZone.includes(fromRow) || promotionZone.includes(toRow)) {
        let mandatory = false;
        if (piece.type === "pawn" || piece.type === "lance") {
          if ((piece.owner === "sente" && toRow === 0) || (piece.owner === "gote" && toRow === 8))
            mandatory = true;
        }
        if (piece.type === "knight") {
          if ((piece.owner === "sente" && toRow <= 1) || (piece.owner === "gote" && toRow >= 7))
            mandatory = true;
        }
        let promote = false;
        if (mandatory) {
          promote = true;
        } else {
          promote = await customConfirmPromotion(piece.owner);
        }
        if (promote)
          promotePiece(piece);
      }
    }
    gameState.moveCount++;
  }

  function isPromotable(type) {
    return (type === "pawn" || type === "lance" || type === "knight" ||
            type === "silver" || type === "rook" || type === "bishop");
  }

  function promotePiece(piece) {
    piece.promoted = true;
    if (piece.type === "rook") { piece.type = "rook_promoted"; }
    else if (piece.type === "bishop") { piece.type = "bishop_promoted"; }
  }

  function capturePiece(piece) {
    piece.promoted = false;
    if (piece.type === "rook_promoted") piece.type = "rook";
    if (piece.type === "bishop_promoted") piece.type = "bishop";
    piece.owner = gameState.activePlayer;
    if (gameState.activePlayer === "sente")
      gameState.senteHand.push(piece);
    else
      gameState.goteHand.push(piece);
  }

  function isKingInCheckInState(state, owner) {
    const kingPos = findKing(state, owner);
    if (!kingPos) return true;
    const attacker = (owner === "sente") ? "gote" : "sente";
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        const p = state.board[r][c];
        if (p && p.owner === attacker) {
          const moves = getLegalMovesInState(state, p, r, c);
          for (const move of moves)
            if (move.r === kingPos.r && move.c === kingPos.c)
              return true;
        }
      }
    }
    return false;
  }

  function findKing(state, owner) {
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        const p = state.board[r][c];
        if (p && p.owner === owner && p.type === "king")
          return { r: r, c: c };
      }
    }
    return null;
  }

  // 影武者将棋関連の関数
  function findShadowPiece(state, owner) {
    const shadowPieceId = owner === "sente" ? state.shadowPieces.sente : state.shadowPieces.gote;
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        const p = state.board[r][c];
        if (p && p.owner === owner && p.id === shadowPieceId) {
          return { piece: p, r: r, c: c };
        }
      }
    }
    return null;
  }

  function isTargetShadowPiece(target) {
    const shadowPieceId = target.owner === "sente" ? 
      gameState.shadowPieces.sente : gameState.shadowPieces.gote;
    return target.id === shadowPieceId;
  }

  function isShadowPieceInCheck(state, shadowPiece, attacker) {
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        const p = state.board[r][c];
        if (p && p.owner === attacker) {
          const moves = getLegalMovesInState(state, p, r, c);
          for (const move of moves) {
            if (move.r === shadowPiece.r && move.c === shadowPiece.c) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }

  async function handleCellClick() {
    const r = parseInt(this.dataset.row);
    const c = parseInt(this.dataset.col);
    
    // 棋譜再生モード中は操作不可
    if (gameState.replayMode) {
      return;
    }
    
    // 影武者選択フェーズの場合
    if (gameState.shadowSelectionPhase) {
      const piece = gameState.board[r][c];
      if (piece && piece.owner === gameState.shadowSelectionPhase) {
        // 影武者駒を選択（王も可）
        gameState.shadowPieces[gameState.shadowSelectionPhase] = piece.id;
        renderBoard();
        updateMessage();
      }
      return;
    }
    
    // かくし将棋の配置フェーズの場合
    if (gameState.setupPhase) {
      // 既に配置された自分の駒をクリックした場合、駒台に戻す
      if (gameState.board[r][c] !== null && gameState.board[r][c].owner === gameState.setupPhase) {
        const piece = gameState.board[r][c];
        const hand = gameState.setupPhase === "sente" ? gameState.senteHand : gameState.goteHand;
        
        // 駒を駒台に戻す
        hand.push(piece);
        gameState.board[r][c] = null;
        
        // 選択状態をリセット
        gameState.selected = null;
        
        // 表示更新
        renderBoard();
        return;
      }
      
      // 持ち駒が選択されている場合のみ配置可能
      if (gameState.selected && gameState.selected.hand && gameState.selected.owner === gameState.setupPhase) {
        const validRows = gameState.setupPhase === "sente" ? [6, 7, 8] : [0, 1, 2];
        if (!validRows.includes(r)) {
          alert("配置可能な範囲ではありません。");
          return;
        }
        
        // 既に自分の駒がある場合は入れ替え
        if (gameState.board[r][c] !== null && gameState.board[r][c].owner === gameState.setupPhase) {
          // 既存の駒を持ち駒に戻す
          const hand = gameState.setupPhase === "sente" ? gameState.senteHand : gameState.goteHand;
          hand.push(gameState.board[r][c]);
        } else if (gameState.board[r][c] !== null) {
          alert("そこには配置できません。");
          return;
        }
        
        // 駒を配置
        const piece = gameState.selected.piece;
        gameState.board[r][c] = piece;
        
        // 持ち駒から削除
        const hand = gameState.setupPhase === "sente" ? gameState.senteHand : gameState.goteHand;
        hand.splice(gameState.selected.index, 1);
        
        // 選択状態をリセット
        gameState.selected = null;
        
        // 表示更新
        renderBoard();
      }
      return;
    }
    
    if (gameState.selected && !gameState.selected.hand &&
        gameState.selected.row === r && gameState.selected.col === c) {
      gameState.selected = null;
      clearHighlights();
      renderBoard();
      return;
    }
    if (gameState.selected && gameState.selected.hand) {
      if (gameState.board[r][c] === null && isLegalDrop(gameState.selected.piece, r, c)) {
        // 王手将棋の場合、駒を打って王手をかけたかチェック
        if (gameState.variants.checkShogi) {
          const clone = cloneGameState(gameState);
          clone.board[r][c] = gameState.selected.piece;
          const opponent = (gameState.activePlayer === "sente") ? "gote" : "sente";
          
          // 影武者将棋も有効な場合、影武者駒への王手をチェック
          if (gameState.variants.shadowShogi) {
            const shadowPiece = findShadowPiece(clone, opponent);
            if (shadowPiece && isShadowPieceInCheck(clone, shadowPiece, gameState.activePlayer)) {
              alert(`${getRoleName(gameState.activePlayer)}の勝ちです！影武者駒に王手をかけました。`);
              return;
            }
          }
          
          // 通常の王手チェック
          if (isKingInCheckInState(clone, opponent)) {
            alert(`${getRoleName(gameState.activePlayer)}の勝ちです！王手をかけました。`);
            return;
          }
        }
        
        dropPiece(gameState.selected, r, c);
        gameState.moveCount++;
        
        // 手番を変更する前の状態を保存
        saveGameState();
        
        // 手番を変更し、選択状態をクリア
        switchTurn();
        gameState.selected = null;
        clearHighlights();
        renderBoard();
        return;
      } else {
        gameState.selected = null;
        clearHighlights();
        renderBoard();
        return;
      }
    }
    if (gameState.selected && !gameState.selected.hand) {
      if (legalMoves.has(cellId(r, c))) {
        await movePiece(gameState.selected.row, gameState.selected.col, r, c);
        gameState.selected = null;
        clearHighlights();
        renderBoard();
        switchTurn();
        return;
      } else {
        const piece = gameState.board[r][c];
        if (piece && piece.owner === gameState.activePlayer) {
          gameState.selected = { row: r, col: c };
          clearHighlights();
          showLegalMoves(r, c);
        } else {
          gameState.selected = null;
          clearHighlights();
          renderBoard();
        }
        return;
      }
    }
    const piece = gameState.board[r][c];
    if (piece && piece.owner === gameState.activePlayer) {
      gameState.selected = { row: r, col: c };
      showLegalMoves(r, c);
    }
  }

  function clearHighlights() { legalMoves.clear(); }

  function showLegalMoves(r, c) {
    clearHighlights();
    const piece = gameState.board[r][c];
    let moves = getLegalMoves(piece, r, c);
    moves.forEach(move => { legalMoves.add(cellId(move.r, move.c)); });
    renderBoard();
  }

  function renderBoard() {
    const boardBody = document.getElementById("board-body");
    boardBody.innerHTML = "";
    for (let r = 0; r < 9; r++) {
      const tr = document.createElement("tr");
      for (let c = 0; c < 9; c++) {
        const td = document.createElement("td");
        td.dataset.row = r;
        td.dataset.col = c;
        
        // 配置フェーズ中の配置可能エリアハイライト
        if (gameState.setupPhase) {
          const validRows = gameState.setupPhase === "sente" ? [6, 7, 8] : [0, 1, 2];
          if (validRows.includes(r)) {
            td.style.backgroundColor = "#E8F5E8";
            td.style.borderColor = "#4CAF50";
          }
        } else if (gameState.shadowSelectionPhase) {
          // 影武者選択フェーズ中のハイライト（王も含め全ての自駒を同じように）
          const piece = gameState.board[r][c];
          if (piece && piece.owner === gameState.shadowSelectionPhase) {
            if (gameState.shadowPieces[gameState.shadowSelectionPhase] === piece.id) {
              td.style.backgroundColor = "#FFE0E0";
              td.style.borderColor = "#FF5722";
            } else {
              td.style.backgroundColor = "#FFF3E0";
              td.style.borderColor = "#FF9800";
            }
          }
        } else {
          // 通常ゲーム中のハイライト
          if (gameState.selected && !gameState.selected.hand &&
              gameState.selected.row === r && gameState.selected.col === c)
            td.classList.add("selected");
          if (legalMoves.has(cellId(r, c)))
            td.classList.add("highlight");
          
          // 影武者将棋で影武者駒をハイライト（デバッグ用、実際は秘匿）
          if (gameState.variants.shadowShogi && gameState.board[r][c] && 
              gameState.board[r][c].id === gameState.shadowPieces.sente) {
            // td.classList.add("shadow-piece"); // 実際は表示しない
          }
          if (gameState.variants.shadowShogi && gameState.board[r][c] && 
              gameState.board[r][c].id === gameState.shadowPieces.gote) {
            // td.classList.add("shadow-piece"); // 実際は表示しない
          }
        }
        
        td.addEventListener("click", handleCellClick);
        const piece = gameState.board[r][c];
        
        // 配置フェーズ中は相手の駒を表示しない
        if (piece && (!gameState.setupPhase || piece.owner === gameState.setupPhase)) {
          const span = document.createElement("span");
          span.classList.add("piece");
          if (piece.owner === "gote") span.classList.add("gote");
          // 王も含め全ての駒で同じクラス・ハイライト
          span.textContent = getPieceSymbol(piece);
          // 影武者選択フェーズで王も含め全ての自駒でspanにも明示的に色を付与
          if (gameState.shadowSelectionPhase && piece.owner === gameState.shadowSelectionPhase) {
            if (gameState.shadowPieces[gameState.shadowSelectionPhase] === piece.id) {
              span.style.backgroundColor = "#FFE0E0";
              span.style.borderColor = "#FF5722";
            } else {
              span.style.backgroundColor = "#FFF3E0";
              span.style.borderColor = "#FF9800";
            }
          }
          td.appendChild(span);
        }
        tr.appendChild(td);
      }
      boardBody.appendChild(tr);
    }
    renderHands();
    updateHandPiecesSize();
    updateBoardPiecesFontSize();
  }

  function renderHands() {
    const senteHandArea = document.getElementById("sente-hand-area");
    const goteHandArea = document.getElementById("gote-hand-area");
    senteHandArea.innerHTML = "";
    goteHandArea.innerHTML = "";
    
    // 配置フェーズ中は現在配置中のプレイヤーの持ち駒のみ表示
    if (gameState.setupPhase) {
      if (gameState.setupPhase === "sente") {
        goteHandArea.innerHTML = "";
      } else {
        senteHandArea.innerHTML = "";
      }
    }
    
    // 影武者選択フェーズ中は通常通り表示
    if (gameState.shadowSelectionPhase) {
      // 特別な処理は不要、通常通り表示
    }
    
    senteHandArea.style.height = "100%";
    senteHandArea.style.width = "100%";
    goteHandArea.style.height = "100%";
    goteHandArea.style.width = "100%";
    
    senteHandArea.style.display = "flex";
    senteHandArea.style.flexDirection = "column";
    senteHandArea.style.flexWrap = "wrap";
    senteHandArea.style.alignContent = "flex-start";

    goteHandArea.style.display = "flex";
    goteHandArea.style.flexDirection = "column";
    goteHandArea.style.flexWrap = "wrap";
    goteHandArea.style.alignContent = "flex-start";
    
    const orderMapping = {
      "pawn": 0,
      "lance": 1,
      "knight": 2,
      "silver": 3,
      "gold": 4,
      "bishop": 5,
      "rook": 6
    };
    
    gameState.senteHand.sort((a, b) => (orderMapping[a.type] ?? 100) - (orderMapping[b.type] ?? 100));
    gameState.goteHand.sort((a, b) => (orderMapping[a.type] ?? 100) - (orderMapping[b.type] ?? 100));
    
    gameState.senteHand.forEach((piece, index) => {
      const span = document.createElement("span");
      span.classList.add("hand-piece");
      if (gameState.selected && gameState.selected.hand &&
          gameState.selected.owner === "sente" &&
          gameState.selected.index === index)
        span.classList.add("selected");
      span.textContent = getPieceSymbol(piece);
      span.dataset.handIndex = index;
      span.addEventListener("click", () => {
        // 棋譜再生モード中は操作不可
        if (gameState.replayMode) return;
        
        // 配置フェーズ中は現在配置中のプレイヤーのみ操作可能
        if (gameState.setupPhase && gameState.setupPhase !== "sente") return;
        
        // 影武者選択フェーズ中は持ち駒操作不可
        if (gameState.shadowSelectionPhase) return;
        
        const activePlayer = gameState.setupPhase || gameState.activePlayer;
        if (activePlayer === "sente") {
          if (gameState.selected && gameState.selected.hand &&
              gameState.selected.owner === "sente" &&
              gameState.selected.index === index)
            gameState.selected = null;
          else
            gameState.selected = { hand: true, piece, index, owner: "sente" };
          renderBoard();
        }
      });
      senteHandArea.appendChild(span);
    });

    gameState.goteHand.forEach((piece, index) => {
      const span = document.createElement("span");
      span.classList.add("hand-piece");
      if (gameState.selected && gameState.selected.hand &&
          gameState.selected.owner === "gote" &&
          gameState.selected.index === index)
        span.classList.add("selected");
      span.textContent = getPieceSymbol(piece);
      span.dataset.handIndex = index;
      span.addEventListener("click", () => {
        // 棋譜再生モード中は操作不可
        if (gameState.replayMode) return;
        
        // 配置フェーズ中は現在配置中のプレイヤーのみ操作可能
        if (gameState.setupPhase && gameState.setupPhase !== "gote") return;
        
        // 影武者選択フェーズ中は持ち駒操作不可
        if (gameState.shadowSelectionPhase) return;
        
        const activePlayer = gameState.setupPhase || gameState.activePlayer;
        if (activePlayer === "gote") {
          if (gameState.selected && gameState.selected.hand &&
              gameState.selected.owner === "gote" &&
              gameState.selected.index === index)
            gameState.selected = null;
          else
            gameState.selected = { hand: true, piece, index, owner: "gote" };
          renderBoard();
        }
      });
      goteHandArea.appendChild(span);
    });
  }

  function updateHandPiecesSize() {
    const boardContainer = document.getElementById("board-container");
    const basePieceSize = (boardContainer.clientWidth / 9) * 0.8;
    document.querySelectorAll('.hand-piece').forEach(piece => {
      piece.style.width = basePieceSize + "px";
      piece.style.height = basePieceSize + "px";
    });
  }

  function initGame() {
    // 先後入れ替え状態をリセット
    swapped = false;
    
    // 変則将棋モードの設定を取得
    const variants = {
      shadowShogi: document.getElementById("shadow-shogi").checked,
      hiddenShogi: document.getElementById("hidden-shogi").checked,
      doubleMove: document.getElementById("double-move").checked,
      reflectionAngle: document.getElementById("reflection-angle").checked,
      doublePawn: document.getElementById("double-pawn").checked,
      capitalReturn: document.getElementById("capital-return").checked,
      checkShogi: document.getElementById("check-shogi").checked
    };
    
    gameState = {
      board: [],
      activePlayer: swapped ? "gote" : "sente",
      senteHand: [],
      goteHand: [],
      selected: null,
      moveCount: 0,
      moveCountInTurn: 0,
      variants: variants,
      shadowPieces: { sente: null, gote: null },
      setupPhase: variants.hiddenShogi ? "sente" : null,
      shadowSelectionPhase: null,
      pieceIdCounter: 0,
      gameHistory: [],
      undoUsed: { sente: false, gote: false },
      replayMode: false,
      replayPosition: -1
    };
    
    for (let r = 0; r < 9; r++) { gameState.board.push(new Array(9).fill(null)); }
    
    if (variants.hiddenShogi) {
      // かくし将棋の場合、駒を駒台に配置
      setupHiddenShogi();
    } else {
      // 通常の初期配置
      setupNormalGame();
    }
    
    updateMessage();
    renderBoard();
    initializeTimer();
    
    if (!variants.hiddenShogi && !variants.shadowShogi) {
      startTimerForPlayer(gameState.activePlayer);
    }
    
    // 待ったボタンの表示状態を更新
    updateUndoButtonState();
    
    // role-displayを初期状態にリセット
    const senteRole = document.querySelector("#sente-clock .role-display");
    const goteRole = document.querySelector("#gote-clock .role-display");
    if (senteRole && goteRole) {
      senteRole.setAttribute("data-original", "先手");
      goteRole.setAttribute("data-original", "後手");
      senteRole.textContent = "先手";
      goteRole.textContent = "後手";
    }
    
    updateRoleDisplays();
    
    // 初期状態を保存
    saveGameState();
  }

  function setupNormalGame() {
    // 後手初期配置（上段）パート4
    gameState.board[0][0] = { type: 'lance', owner: "gote", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[0][1] = { type: 'knight', owner: "gote", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[0][2] = { type: 'silver', owner: "gote", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[0][3] = { type: 'gold', owner: "gote", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[0][4] = { type: 'king', owner: "gote", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[0][5] = { type: 'gold', owner: "gote", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[0][6] = { type: 'silver', owner: "gote", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[0][7] = { type: 'knight', owner: "gote", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[0][8] = { type: 'lance', owner: "gote", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[1][1] = { type: 'rook', owner: "gote", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[1][7] = { type: 'bishop', owner: "gote", promoted: false, id: gameState.pieceIdCounter++ };
    for (let c = 0; c < 9; c++) { 
      gameState.board[2][c] = { type: 'pawn', owner: "gote", promoted: false, id: gameState.pieceIdCounter++ }; 
    }
    
    // 先手初期配置（下段）
    for (let c = 0; c < 9; c++) { 
      gameState.board[6][c] = { type: 'pawn', owner: "sente", promoted: false, id: gameState.pieceIdCounter++ }; 
    }
    gameState.board[7][1] = { type: 'bishop', owner: "sente", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[7][7] = { type: 'rook', owner: "sente", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[8][0] = { type: 'lance', owner: "sente", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[8][1] = { type: 'knight', owner: "sente", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[8][2] = { type: 'silver', owner: "sente", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[8][3] = { type: 'gold', owner: "sente", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[8][4] = { type: 'king', owner: "sente", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[8][5] = { type: 'gold', owner: "sente", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[8][6] = { type: 'silver', owner: "sente", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[8][7] = { type: 'knight', owner: "sente", promoted: false, id: gameState.pieceIdCounter++ };
    gameState.board[8][8] = { type: 'lance', owner: "sente", promoted: false, id: gameState.pieceIdCounter++ };
    
    // 影武者将棋の場合、影武者駒選択フェーズを開始
    if (gameState.variants.shadowShogi) {
      gameState.shadowSelectionPhase = "sente";
      showShadowSelectionPhase();
    }
  }

  function setupHiddenShogi() {
    // 先手の駒を駒台に配置
    const senteStartingPieces = [
      { type: 'lance', count: 2 },
      { type: 'knight', count: 2 },
      { type: 'silver', count: 2 },
      { type: 'gold', count: 2 },
      { type: 'king', count: 1 },
      { type: 'rook', count: 1 },
      { type: 'bishop', count: 1 },
      { type: 'pawn', count: 9 }
    ];
    
    senteStartingPieces.forEach(pieceInfo => {
      for (let i = 0; i < pieceInfo.count; i++) {
        gameState.senteHand.push({
          type: pieceInfo.type,
          owner: "sente",
          promoted: false,
          id: gameState.pieceIdCounter++
        });
      }
    });
    
    // 後手の駒を駒台に配置
    const goteStartingPieces = [
      { type: 'lance', count: 2 },
      { type: 'knight', count: 2 },
      { type: 'silver', count: 2 },
      { type: 'gold', count: 2 },
      { type: 'king', count: 1 },
      { type: 'rook', count: 1 },
      { type: 'bishop', count: 1 },
      { type: 'pawn', count: 9 }
    ];
    
    goteStartingPieces.forEach(pieceInfo => {
      for (let i = 0; i < pieceInfo.count; i++) {
        gameState.goteHand.push({
          type: pieceInfo.type,
          owner: "gote",
          promoted: false,
          id: gameState.pieceIdCounter++
        });
      }
    });
    
    // 先手の配置フェーズから開始
    pauseTimer();
    showSetupPhase();
  }

  function selectShadowPieces() {
    // 影武者駒をランダムに選択（玉以外から）
    const sentePieces = [];
    const gotePieces = [];
    
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        const piece = gameState.board[r][c];
        if (piece && piece.type !== "king") {
          if (piece.owner === "sente") {
            sentePieces.push(piece.id);
          } else {
            gotePieces.push(piece.id);
          }
        }
      }
    }
    
    gameState.shadowPieces.sente = sentePieces[Math.floor(Math.random() * sentePieces.length)];
    gameState.shadowPieces.gote = gotePieces[Math.floor(Math.random() * gotePieces.length)];
  }

  function showSetupPhase() {
    // 配置完了ボタンを追加
    const setupButton = document.createElement("button");
    setupButton.id = "setup-complete-button";
    setupButton.textContent = "配置完了";
    setupButton.style.fontSize = "18px";
    setupButton.style.padding = "10px 20px";
    setupButton.style.margin = "10px";
    setupButton.style.backgroundColor = "#4CAF50";
    setupButton.style.color = "white";
    setupButton.style.border = "none";
    setupButton.style.borderRadius = "5px";
    setupButton.style.cursor = "pointer";
    setupButton.onclick = finishSetupPhase;
    
    // リセットボタンの隣に配置
    const resetContainer = document.querySelector('.reset-container');
    resetContainer.appendChild(setupButton);
    
    // 盤面と駒台を更新
    renderBoard();
    updateMessage();
  }

  function showShadowSelectionPhase() {
    // 影武者選択完了ボタンを追加
    const shadowButton = document.createElement("button");
    shadowButton.id = "shadow-selection-complete-button";
    shadowButton.textContent = "影武者選択完了";
    shadowButton.style.fontSize = "18px";
    shadowButton.style.padding = "10px 20px";
    shadowButton.style.margin = "10px";
    shadowButton.style.backgroundColor = "#FF9800";
    shadowButton.style.color = "white";
    shadowButton.style.border = "none";
    shadowButton.style.borderRadius = "5px";
    shadowButton.style.cursor = "pointer";
    shadowButton.onclick = finishShadowSelectionPhase;
    
    // リセットボタンの隣に配置
    const resetContainer = document.querySelector('.reset-container');
    resetContainer.appendChild(shadowButton);
    
    // 盤面と駒台を更新
    renderBoard();
    updateMessage();
  }



  // 影武者選択完了
  window.finishShadowSelectionPhase = function() {
    if (gameState.shadowSelectionPhase === "sente") {
      // 先手の影武者選択が完了、後手の番
      if (gameState.shadowPieces.sente === null) {
        alert(`${getRoleName("sente")}の影武者駒を選択してください。`);
        return;
      }
      
      gameState.shadowSelectionPhase = "gote";
      
      // ボタンテキストを更新
      const shadowButton = document.getElementById("shadow-selection-complete-button");
      if (shadowButton) {
        shadowButton.textContent = "影武者選択完了";
      }
      
      renderBoard();
      updateMessage();
    } else {
      // 後手の影武者選択も完了、ゲーム開始
      if (gameState.shadowPieces.gote === null) {
        alert(`${getRoleName("gote")}の影武者駒を選択してください。`);
        return;
      }
      
      gameState.shadowSelectionPhase = null;
      
      // 影武者選択完了ボタンを削除
      const shadowButton = document.getElementById("shadow-selection-complete-button");
      if (shadowButton) {
        shadowButton.remove();
      }
      
      // 通常の盤面表示に戻す
      renderBoard();
      updateMessage();
      startTimerForPlayer(gameState.activePlayer);
    }
  };

  // かくし将棋の配置完了
  window.finishSetupPhase = function() {
    // 残った持ち駒を削除
    if (gameState.setupPhase === "sente") {
      gameState.senteHand = [];
    } else {
      gameState.goteHand = [];
    }
    
    if (gameState.setupPhase === "sente") {
      // 先手の配置が完了、後手の番
      gameState.setupPhase = "gote";
      
      // 配置完了ボタンを更新
      const setupButton = document.getElementById("setup-complete-button");
      if (setupButton) {
        setupButton.textContent = "配置完了";
      }
      
      renderBoard();
      updateMessage();
    } else {
      // 後手の配置も完了、ゲーム開始
      gameState.setupPhase = null;
      
      // 配置完了ボタンを削除
      const setupButton = document.getElementById("setup-complete-button");
      if (setupButton) {
        setupButton.remove();
      }
      
      // 影武者将棋の場合、影武者駒選択フェーズを開始
      if (gameState.variants.shadowShogi) {
        gameState.shadowSelectionPhase = "sente";
        showShadowSelectionPhase();
        return;
      }
      
      // 通常の盤面表示に戻す
      renderBoard();
      updateMessage();
      startTimerForPlayer(gameState.activePlayer);
    }
  };

  function selectShadowPiecesForHiddenShogi() {
    const sentePieces = [];
    const gotePieces = [];
    
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        const piece = gameState.board[r][c];
        if (piece && piece.type !== "king") {
          if (piece.owner === "sente") {
            sentePieces.push(piece.id);
          } else {
            gotePieces.push(piece.id);
          }
        }
      }
    }
    
    if (sentePieces.length > 0) {
      gameState.shadowPieces.sente = sentePieces[Math.floor(Math.random() * sentePieces.length)];
    }
    if (gotePieces.length > 0) {
      gameState.shadowPieces.gote = gotePieces[Math.floor(Math.random() * gotePieces.length)];
    }
  }

  document.addEventListener("DOMContentLoaded", function() {
    // 変則将棋モードの設定変更時の処理
    document.getElementById("capital-return").addEventListener("change", function() {
      document.getElementById("capital-return-setting").style.display = 
        this.checked ? "block" : "none";
    });
    
    initGame();
  });
</script>
<script>
  // プレイヤーの向きに合わせたカスタムプロモーション確認モーダル
  function customConfirmPromotion(owner) {
    return new Promise((resolve) => {
      // モーダル用オーバーレイを作成（全画面モード中も必ず表示）
      const modalOverlay = document.createElement("div");
      modalOverlay.style.position = "fixed";
      modalOverlay.style.top = "0";
      modalOverlay.style.left = "0";
      modalOverlay.style.width = "100%";
      modalOverlay.style.height = "100%";
      modalOverlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
      modalOverlay.style.display = "flex";
      modalOverlay.style.alignItems = "center";
      modalOverlay.style.justifyContent = "center";
      modalOverlay.style.zIndex = "99999";
      
      // モーダルコンテナの作成
      const modalContainer = document.createElement("div");
      modalContainer.style.background = "#fff";
      modalContainer.style.padding = "20px";
      modalContainer.style.borderRadius = "10px";
      modalContainer.style.boxShadow = "0 0 10px rgba(0,0,0,0.5)";
      modalContainer.style.textAlign = "center";
      
      // プレイヤーに合わせて回転（先手なら 90°、後手なら -90°）
      let rotationAngle = 0;
      if (owner === "sente") {
         rotationAngle = 90;
      } else if (owner === "gote") {
         rotationAngle = -90;
      }
      modalContainer.style.transform = "rotate(" + rotationAngle + "deg)";
      
      // メッセージ作成
      const message = document.createElement("div");
      message.textContent = "この駒を成りますか？";
      message.style.fontSize = "18px";
      message.style.marginBottom = "20px";
      modalContainer.appendChild(message);
      
      // ボタンコンテナの作成
      const buttonsContainer = document.createElement("div");
      
      // 「成る」ボタン（サイズ拡大）
      const promoteButton = document.createElement("button");
      promoteButton.textContent = "成る";
      promoteButton.style.marginRight = "10px";
      promoteButton.style.fontSize = "18px";
      promoteButton.style.padding = "10px 20px";
      promoteButton.addEventListener("click", () => {
         modalOverlay.parentNode.removeChild(modalOverlay);
         resolve(true);
      });
      buttonsContainer.appendChild(promoteButton);
      
      // 「成らない」ボタン（サイズ拡大）
      const noPromoteButton = document.createElement("button");
      noPromoteButton.textContent = "成らない";
      noPromoteButton.style.fontSize = "18px";
      noPromoteButton.style.padding = "10px 20px";
      noPromoteButton.addEventListener("click", () => {
         modalOverlay.parentNode.removeChild(modalOverlay);
         resolve(false);
      });
      buttonsContainer.appendChild(noPromoteButton);
      
      modalContainer.appendChild(buttonsContainer);
      modalOverlay.appendChild(modalContainer);
      
      // 全画面モード時は全画面要素に、そうでなければ通常の body に追加
      const fsElement = document.fullscreenElement ||
                        document.webkitFullscreenElement ||
                        document.mozFullScreenElement ||
                        document.msFullscreenElement;
      if(fsElement) {
         fsElement.appendChild(modalOverlay);
      } else {
         document.body.appendChild(modalOverlay);
      }
    });
  }

  // 先後入れ替えの処理
  document.getElementById("swap-button").addEventListener("click", swapSides);
  
  function swapSides() {
    if (gameState.moveCount > 0) {
      alert("初形状態でなければ先後入れ替えはできません。");
      return;
    }
    
    if (gameState.setupPhase) {
      alert("配置フェーズ中は先後入れ替えはできません。");
      return;
    }
    
    if (gameState.shadowSelectionPhase) {
      alert("影武者選択フェーズ中は先後入れ替えはできません。");
      return;
    }
    
    if (gameState.replayMode) {
      alert("棋譜再生モード中は先後入れ替えはできません。");
      return;
    }
    
    swapped = !swapped;
    gameState.activePlayer = swapped ? "gote" : "sente";
    
    // undoUsedフラグを入れ替える
    const tempUndoUsed = gameState.undoUsed.sente;
    gameState.undoUsed.sente = gameState.undoUsed.gote;
    gameState.undoUsed.gote = tempUndoUsed;
    
    updateMessage();
    updateUndoButtonState();
    
    const senteRole = document.querySelector("#sente-clock .role-display");
    const goteRole = document.querySelector("#gote-clock .role-display");
    if (senteRole && goteRole) {
      senteRole.setAttribute("data-original", swapped ? "後手" : "先手");
      goteRole.setAttribute("data-original", swapped ? "先手" : "後手");
      senteRole.textContent = senteRole.getAttribute("data-original");
      goteRole.textContent = goteRole.getAttribute("data-original");
      updateRoleDisplays();
    }
    pauseTimer();
    startTimerForPlayer(gameState.activePlayer);
  }
  
  // role-display の向きを更新する処理
  function updateRoleDisplays() {
    const senteRole = document.querySelector("#sente-clock .role-display");
    if (senteRole) {
      const text = senteRole.getAttribute("data-original") || senteRole.textContent.trim();
      senteRole.innerHTML = "";
      const chars = [...text].reverse();
      for (const char of chars) {
        const span = document.createElement("span");
        span.style.display = "inline-block";
        span.style.transform = "rotate(90deg)";
        span.textContent = char;
        senteRole.appendChild(span);
      }
    }
    const goteRole = document.querySelector("#gote-clock .role-display");
    if (goteRole) {
      const text = goteRole.getAttribute("data-original") || goteRole.textContent.trim();
      goteRole.innerHTML = "";
      for (const char of text) {
        const span = document.createElement("span");
        span.style.display = "inline-block";
        span.style.transform = "rotate(-90deg)";
        span.textContent = char;
        goteRole.appendChild(span);
      }
    }
  }
  
  document.addEventListener("DOMContentLoaded", function() {
    updateRoleDisplays();
  });
  
  // リセットボタンの処理
  document.getElementById("reset-button").addEventListener("click", function(){
    if (confirm("本当にリセットしますか？")) {
      pauseTimer();
      
      // 配置完了ボタンを削除
      const setupButton = document.getElementById("setup-complete-button");
      if (setupButton) {
        setupButton.remove();
      }
      
      // 影武者選択完了ボタンを削除
      const shadowButton = document.getElementById("shadow-selection-complete-button");
      if (shadowButton) {
        shadowButton.remove();
      }
      
      // 棋譜再生コントロールを削除
      hideReplayControls();
      
      initGame();
    }
  });

  // 待ったボタンの処理
  document.getElementById("undo-button").addEventListener("click", function(){
    performUndo();
  });

  // 棋譜再生ボタンの処理
  document.getElementById("replay-button").addEventListener("click", function(){
    enterReplayMode();
  });
  
  // 全画面モードボタンの処理（対象は #game-area のみ）
  document.getElementById("fullscreen-button").addEventListener("click", function() {
    const gameArea = document.getElementById("game-area");
    if (!document.fullscreenElement &&
        !document.webkitFullscreenElement &&
        !document.mozFullScreenElement &&
        !document.msFullscreenElement) {
      if (gameArea.requestFullscreen) { gameArea.requestFullscreen(); }
      else if (gameArea.msRequestFullscreen) { gameArea.msRequestFullscreen(); }
      else if (gameArea.mozRequestFullScreen) { gameArea.mozRequestFullScreen(); }
      else if (gameArea.webkitRequestFullscreen) { gameArea.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT); }
    } else {
      if (document.exitFullscreen) { document.exitFullscreen(); }
      else if (document.msExitFullscreen) { document.msExitFullscreen(); }
      else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); }
      else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); }
    }
  });
  
  // 全画面モード時と通常時のレイアウト調整
    function updateFullScreenLayout() {
    const boardContainer = document.getElementById("board-container");
    const senteHand = document.getElementById("sente-hand-container");
    const goteHand = document.getElementById("gote-hand-container");

    // 全画面モードの場合、利用可能領域に合わせてサイズを調整
    if (document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        document.msFullscreenElement) {
      const availableWidth = window.innerWidth - 200; // 両側の持駒領域 200px を除く
      const availableHeight = window.innerHeight;
      const boardSize = Math.min(availableWidth, availableHeight);

      boardContainer.style.width = boardSize + "px";
      boardContainer.style.height = boardSize + "px";
      senteHand.style.height = boardSize + "px";
      goteHand.style.height = boardSize + "px";
      
      // 駒台のタイマーサイズも調整
      updateHandTimersSize(boardSize);
    } else {
      // 通常時は元のサイズに戻す
      boardContainer.style.width = "450px";
      boardContainer.style.height = "450px";
      senteHand.style.height = "450px";
      goteHand.style.height = "450px";
      
      // 駒台のタイマーサイズも元に戻す
      updateHandTimersSize(450);
    }
    // 持ち駒のサイズも更新
    updateHandPiecesSize();
  }

  function updateHandTimersSize(boardSize) {
    const senteHandTimer = document.getElementById("sente-hand-timer");
    const goteHandTimer = document.getElementById("gote-hand-timer");
    
    // ボードサイズに比例してタイマーサイズを調整
    const fontSize = Math.max(8, Math.min(14, boardSize / 40));
    const padding = Math.max(2, Math.min(6, boardSize / 100));
    
    if (senteHandTimer) {
      senteHandTimer.style.fontSize = fontSize + "px";
      senteHandTimer.style.padding = padding + "px " + (padding * 2) + "px";
    }
    
    if (goteHandTimer) {
      goteHandTimer.style.fontSize = fontSize + "px";
      goteHandTimer.style.padding = padding + "px " + (padding * 2) + "px";
    }
  }
  
  document.addEventListener("fullscreenchange", updateFullScreenLayout);
  document.addEventListener("webkitfullscreenchange", updateFullScreenLayout);
  document.addEventListener("mozfullscreenchange", updateFullScreenLayout);
  document.addEventListener("msfullscreenchange", updateFullScreenLayout);
  
  window.addEventListener("resize", function() {
    updateFullScreenLayout();
  });
  // 持ち駒のサイズと文字サイズ更新。常に基礎サイズの半分に設定
  function updateHandPiecesSize() {
    const boardContainer = document.getElementById("board-container");
    const basePieceSize = (boardContainer.clientWidth / 9) * 0.8;
    document.querySelectorAll('.hand-piece').forEach(piece => {
      piece.style.width = basePieceSize + "px";
      piece.style.height = basePieceSize + "px";
      piece.style.fontSize = (basePieceSize / 2) + "px";
    });
  }
  
  // 盤上の駒の文字サイズ・表示位置更新。常にマスの中央に配置するため translate(15%, 0%) を適用
  function updateBoardPiecesFontSize() {
    const boardContainer = document.getElementById("board-container");
    const basePieceSize = (boardContainer.clientWidth / 9) * 0.8;
    document.querySelectorAll('#board-container .piece').forEach(piece => {
         piece.style.fontSize = (basePieceSize / 2) + "px";
         // translate(15%, 0%) にして、盤上駒を中央に配置
         if (piece.classList.contains("gote"))
            piece.style.transform = "translate(15%, 0%) rotate(180deg)";
         else
            piece.style.transform = "translate(15%, 0%) rotate(0deg)";
    });
  }
  
  // renderBoard 内で新たに生成された盤上の駒にも、スタイル調整を適用する
  function renderBoard() {
    const boardBody = document.getElementById("board-body");
    boardBody.innerHTML = "";
    for (let r = 0; r < 9; r++) {
      const tr = document.createElement("tr");
      for (let c = 0; c < 9; c++) {
        const td = document.createElement("td");
        td.dataset.row = r;
        td.dataset.col = c;
        
        // 配置フェーズ中の配置可能エリアハイライト
        if (gameState.setupPhase) {
          const validRows = gameState.setupPhase === "sente" ? [6, 7, 8] : [0, 1, 2];
          if (validRows.includes(r)) {
            td.style.backgroundColor = "#E8F5E8";
            td.style.borderColor = "#4CAF50";
          }
        } else if (gameState.shadowSelectionPhase) {
          // 影武者選択フェーズ中のハイライト（王も含め全ての自駒を同じように）
          const piece = gameState.board[r][c];
          if (piece && piece.owner === gameState.shadowSelectionPhase) {
            if (gameState.shadowPieces[gameState.shadowSelectionPhase] === piece.id) {
              // 選択済みの影武者駒をハイライト
              td.style.backgroundColor = "#FFE0E0";
              td.style.borderColor = "#FF5722";
            } else {
              // 選択可能な駒をハイライト
              td.style.backgroundColor = "#FFF3E0";
              td.style.borderColor = "#FF9800";
            }
          }
        } else {
          // 通常ゲーム中のハイライト
          if (gameState.selected && !gameState.selected.hand &&
              gameState.selected.row === r && gameState.selected.col === c)
            td.classList.add("selected");
          if (legalMoves.has(cellId(r, c)))
            td.classList.add("highlight");
        }
        
        td.addEventListener("click", handleCellClick);
        const piece = gameState.board[r][c];
        
        // 配置フェーズ中は相手の駒を表示しない
        if (piece && (!gameState.setupPhase || piece.owner === gameState.setupPhase)) {
          const span = document.createElement("span");
          span.classList.add("piece");
          if (piece.owner === "gote") span.classList.add("gote");
          span.textContent = getPieceSymbol(piece);
          td.appendChild(span);
        }
        tr.appendChild(td);
      }
      boardBody.appendChild(tr);
    }
    renderHands();
    updateHandPiecesSize();
    updateBoardPiecesFontSize();
  }
</script>
<script>
  // カスタムピンチジェスチャーによるズーム処理（サイト全体対象）パート5
  let initialDistance = null;
  let initialScale = 1;
  let currentScale = 1;
  const minScale = 0.4;
  const maxScale = 2;  

  // 2本指間の距離を計算する関数
  function getDistance(touches) {
    if (touches.length < 2) return 0;
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // タッチ開始時
  function onTouchStart(e) {
    if (e.touches.length === 2) {
      initialDistance = getDistance(e.touches);
      initialScale = currentScale;
    }
  }

  // タッチ移動時（ピンチイン・ピンチアウトの両方に対応）
  function onTouchMove(e) {
    if (e.touches.length === 2 && initialDistance !== null) {
      let newDistance = getDistance(e.touches);
      let scaleFactor = newDistance / initialDistance;
      // ここでの scaleFactor が 1 より小さければピンチインとなり、1 より大きければピンチアウトとなる
      currentScale = initialScale * scaleFactor;
      // 値を minScale と maxScale の間に調整
      currentScale = Math.min(maxScale, Math.max(minScale, currentScale));

      // サイト全体（document.body）に対してtransformでズームを適用
      document.body.style.transform = "scale(" + currentScale + ")";
      document.body.style.transformOrigin = "center center";

      // ブラウザ標準のズームと競合させないために preventDefault() を呼び出す
      e.preventDefault();
    }
  }

  // タッチ終了時：初期値をリセット
  function onTouchEnd(e) {
    if (e.touches.length < 2) {
      initialDistance = null;
    }
  }

  // DOM読み込み後にイベントリスナーを登録
  document.addEventListener("DOMContentLoaded", function() {
    document.body.addEventListener("touchstart", onTouchStart, { passive: false });
    document.body.addEventListener("touchmove", onTouchMove, { passive: false });
    document.body.addEventListener("touchend", onTouchEnd, { passive: false });
  });
</script>
</body>
</html>
